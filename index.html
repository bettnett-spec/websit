<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Infinite Random Obby</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; -webkit-user-select: none; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 8px;
            pointer-events: none;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
            z-index: 998; 
        }
        #checkpoint-msg {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #FFFF00;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            z-index: 998; 
        }
        
        #blocker {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            color: white;
            z-index: 1001; 
        }
        #instructions {
            font-size: 24px;
            cursor: pointer;
            text-align: center;
            padding: 20px;
            background: rgba(0,0,0,0.7);
            border-radius: 10px;
            border: 2px solid white;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            border: 1px solid black;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 1000; 
        }
        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 30px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            z-index: 1002;
            display: none; /* Hidden by default */
        }
    </style>
</head>
<body>


    <div id="info">Stage: <span id="stage-display">1</span></div>
    <div id="checkpoint-msg">CHECKPOINT! NEXT LEVEL GENERATED</div>
    <div id="crosshair"></div>
    <div id="loader">Loading 3D Assets...</div>


    <div id="blocker">
        <div id="instructions">
            <span style="font-size:30px">CLICK TO PLAY</span><br/><br/>
            WASD to Move<br/>
            SPACE to Jump<br/>
            SHIFT (Hold) to Hang on Ledges<br/>
            SPACE (While Hanging) to Wall Jump<br/>
            (Look L/R to aim Wall Jump)<br/>
            Scroll to Zoom<br/>
        </div>
    </div>


    <!-- SOUND EFFECTS -->
    <audio id="sfx-jump" src="jump.mp3"></audio>
    <audio id="sfx-check" src="checkpoint.wav"></audio>
    <audio id="sfx-death" src="death.mp3"></audio>
    <audio id="sfx-fire" src="firedeath.mp3"></audio>
    <audio id="sfx-walk" src="walk.mp3" loop></audio>


    <!-- Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- REQUIRED for loading OBJ models (Updated CDN link structure) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/MTLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>


    <script>
        // --- Game Constants ---
        const PLAYER_HEIGHT = 1.6; 
        const PLAYER_SPEED_RUN = 0.22; 
        const PLAYER_SPEED_WALK = 0.08;
        const JUMP_FORCE = 0.55;   
        const GRAVITY = 0.035;     
        const CLIMB_SPEED = 0.15;
        const PI_2 = Math.PI / 2;
        
        // --- Global Variables ---
        let camera, scene, renderer;
        let playerMesh; // Player Group (root of the character)
        let torsoMesh; // Reference to the actual visible torso mesh
        let headMesh;  // Reference to the actual visible head mesh
        let platforms = [];
        let clock; 
        let isPlayerLoaded = false;
        
        // Physics State
        let playerVelocity = new THREE.Vector3();
        let momentum = new THREE.Vector3(); 
        let isGrounded = false;
        
        // Climbing State
        let isClimbing = false;
        let climbPhase = 0; 
        let climbTimer = 0; 
        let climbStartPos = new THREE.Vector3(); 
        let climbTargetPos = new THREE.Vector3(); 
        let climbNormal = new THREE.Vector3(); 
        let airTime = 0; 
        
        // Game State
        let spawnPoint = new THREE.Vector3(0, 5, 0);
        let currentStage = 1;
        let nextStageStart = new THREE.Vector3(0, 0, 0); 
        let stageDirection = new THREE.Vector3(0, 0, -1); 
        
        // Input State
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let isShiftPressed = false;
        let isSpacePressed = false;
        
        // Camera State
        let euler = new THREE.Euler(0, 0, 0, 'YXZ');
        let cameraZoom = 6; 
        const MIN_ZOOM = 0.1; 
        const MAX_ZOOM = 15;
        
        // Pointer Lock
        let isLocked = false;
        const blocker = document.getElementById('blocker');
        const instructions = document.getElementById('instructions');
        const crosshair = document.getElementById('crosshair');
        const loaderDiv = document.getElementById('loader');


        // Sound Elements
        const sfxJump = document.getElementById('sfx-jump');
        const sfxCheck = document.getElementById('sfx-check');
        const sfxDeath = document.getElementById('sfx-death');
        const sfxFire = document.getElementById('sfx-fire');
        const sfxWalk = document.getElementById('sfx-walk');
        
        if(sfxWalk) sfxWalk.volume = 0.4; 


        init();
        
        // --- Level Generation Functions (Moved up to fix ReferenceError) ---
        function createPlatform(x, y, z, w, h, d, color, type = 'normal') {
            const geometry = new THREE.BoxGeometry(w, h, d);
            const material = new THREE.MeshLambertMaterial({ color: color });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);


            const platformData = {
                mesh: mesh,
                box: new THREE.Box3().setFromObject(mesh), 
                width: w,
                height: h,
                depth: d,
                type: type,
                stage: currentStage
            };
            platforms.push(platformData);
            return mesh;
        }


        function generateRandomStage() {
            const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff];
            const stageColor = colors[Math.floor(Math.random() * colors.length)];
            
            let curX = nextStageStart.x;
            let curY = nextStageStart.y;
            let curZ = nextStageStart.z;


            const obstaclesCount = 5 + Math.floor(Math.random() * 4); 


            for (let i = 0; i < obstaclesCount; i++) {
                const r = Math.random();
                const gap = 2.5 + Math.random() * 3.0;
                
                const driftX = (Math.random() - 0.5) * 8; 
                const driftY = (Math.random() - 0.4) * 2; 


                curZ -= gap;
                curX += driftX;
                curY += driftY;
                
                if(curX > 40) curX = 40;
                if(curX < -40) curX = -40;


                if (r < 0.3) {
                    const w = 3 + Math.random() * 3;
                    const d = 3 + Math.random() * 3;
                    curZ -= d/2;
                    createPlatform(curX, curY, curZ, w, 1, d, stageColor);
                    curZ -= d/2;
                } 
                else if (r < 0.5) {
                    const len = 8 + Math.random() * 6;
                    createPlatform(curX, curY, curZ - len/2, 4, 1, len, 0x333333);
                    const lavaCount = Math.floor(len / 4); 
                    for(let k=0; k<lavaCount; k++) {
                        const lZ = curZ - (k * 4) - 2;
                        createPlatform(curX, curY + 0.6, lZ, 3.5, 0.2, 1.0, 0xff0000, 'lava');
                    }
                    curZ -= len;
                }
                else if (r < 0.7) {
                     const len = 6 + Math.random() * 6;
                     curZ -= len/2;
                     createPlatform(curX, curY, curZ, 1.2, 1, len, stageColor);
                     curZ -= len/2;
                }
                else {
                    const steps = 3 + Math.floor(Math.random()*3);
                    for(let s=0; s<steps; s++) {
                        curZ -= 2.5; 
                        curX += (Math.random() - 0.5) * 5; 
                        curY += (Math.random() - 0.3) * 1.5; 
                        createPlatform(curX, curY, curZ, 2, 1, 2, stageColor);
                    }
                }
            }


            curZ -= 4;
            createPlatform(curX, curY, curZ - 3, 8, 1, 6, 0x00FF00, 'checkpoint');
            
            const geo = new THREE.CylinderGeometry(0.5, 0.5, 5);
            const mat = new THREE.MeshBasicMaterial({color: 0xffff00});
            const pole = new THREE.Mesh(geo, mat);
            pole.position.set(curX + 3, curY + 2.5, curZ - 3);
            scene.add(pole);


            nextStageStart.set(curX, curY, curZ - 6);
        }

        
        // --- Core Initialization ---
        async function init() {
            clock = new THREE.Clock();

            // Show loader while models load
            loaderDiv.style.display = 'block';
            blocker.style.display = 'flex';
            instructions.style.display = 'none';

            // 1. Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); 
            scene.fog = new THREE.Fog(0x87CEEB, 20, 150);

            // 2. Camera (FOV 85)
            camera = new THREE.PerspectiveCamera(85, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // 3. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // 4. Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            dirLight.shadow.camera.left = -50;
            dirLight.shadow.camera.right = 50;
            dirLight.shadow.camera.top = 50;
            dirLight.shadow.camera.bottom = -50;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // 5. Create Player (Load Model)
            await createPlayer();

            // 6. Create Initial Level
            createPlatform(0, 0, 0, 10, 1, 10, 0xaaaaaa, 'spawn'); 
            nextStageStart.set(0, 0, -5); 
            generateRandomStage();

            // 7. Event Listeners
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('wheel', onScroll); 
            window.addEventListener('resize', onWindowResize);
            
            instructions.addEventListener('click', function() {
                if(!isPlayerLoaded) return;
                
                if(sfxJump) { 
                    sfxJump.play().then(() => {
                        sfxJump.pause();
                        sfxJump.currentTime = 0;
                    }).catch(e => { /* Audio playback error handling */ });
                }
                
                document.body.requestPointerLock();
            });
            document.addEventListener('pointerlockchange', pointerLockChange);
            document.addEventListener('mousemove', onMouseMove);

            loaderDiv.style.display = 'none';
            instructions.style.display = 'block';
            animate();
        }

        /**
         * Loads OBJ model files (using MTL for materials/textures).
         * Uses FileLoader to explicitly load MTL content first for better pathing.
         * @param {string} objPath Path to the OBJ file.
         * @param {string} mtlPath Path to the MTL file.
         * @returns {Promise<THREE.Group>} A promise that resolves with the loaded object group.
         */
        function loadObjModel(objPath, mtlPath) {
            return new Promise((resolve, reject) => {
                const fileLoader = new THREE.FileLoader();

                // 1. Load MTL content explicitly
                fileLoader.load(mtlPath, function (mtlText) {
                    const mtlLoader = new THREE.MTLLoader();
                    
                    // Set the base path for textures explicitly to the current directory
                    mtlLoader.setResourcePath('./');
                    
                    const materials = mtlLoader.parse(mtlText);
                    materials.preload();
                    
                    // 2. Load OBJ content using the parsed materials
                    const objLoader = new THREE.OBJLoader();
                    objLoader.setMaterials(materials);
                    
                    objLoader.load(objPath, function (object) {
                        object.traverse(child => {
                            if (child.isMesh) {
                                child.castShadow = true;
                            }
                        });
                        resolve(object);
                    }, undefined, reject);
                    
                }, undefined, reject);
            });
        }


        // --- Player Creation (Uses Blocky skeleton + OBJ accessories) ---
        async function createPlayer() {
            const group = new THREE.Group();
            
            // Materials (Basic colors for untextured limbs)
            const matTorso = new THREE.MeshLambertMaterial({ color: 0x0000FF }); // Blue
            const matPants = new THREE.MeshLambertMaterial({ color: 0x00FF00 }); // Green
            const matSkin = new THREE.MeshLambertMaterial({ color: 0xFFFF00 }); // Yellow


            // 1. Torso (Used for physics and root of character, made visible for structure)
            torsoMesh = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 0.5), matTorso);
            torsoMesh.position.y = 1;
            group.add(torsoMesh);

            // 2. Head (Used for positioning, set to hidden later as the OBJ assets are the visible head)
            headMesh = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), matSkin);
            headMesh.position.y = 1.8;
            group.add(headMesh);
            
            // The head is used as the anchor point for all facial/hair OBJs
            const headAnchor = headMesh; 

            // 3. Left Leg (Requires X/Z rotation in updateAnimation)
            const legGeo = new THREE.BoxGeometry(0.4, 1.0, 0.4);
            legGeo.translate(0, -0.5, 0); // Pivot at Hip
            const legL = new THREE.Mesh(legGeo, matPants);
            legL.position.set(-0.25, 0.5, 0); 
            group.add(legL);

            // 4. Right Leg (Requires X/Z rotation in updateAnimation)
            const legR = new THREE.Mesh(legGeo, matPants);
            legR.position.set(0.25, 0.5, 0); 
            group.add(legR);

            // 5. Left Arm (Requires X/Z rotation in updateAnimation)
            const armGeo = new THREE.BoxGeometry(0.4, 1.0, 0.4);
            armGeo.translate(0, -0.5, 0); // Pivot at Shoulder
            const armL = new THREE.Mesh(armGeo, matSkin);
            // Positioned to prevent clipping/detachment during rotation
            armL.position.set(-0.7, 1.5, 0); 
            armL.rotation.z = 0; 
            group.add(armL);

            // 6. Right Arm (Requires X/Z rotation in updateAnimation)
            const armR = new THREE.Mesh(armGeo, matSkin);
            armR.position.set(0.7, 1.5, 0); 
            armR.rotation.z = 0; 
            group.add(armR);


            // --- Load Custom OBJ Assets ---
            const [faceObj, hairObj, backpackObj] = await Promise.all([
                loadObjModel('face.obj', 'face.mtl'),
                loadObjModel('hair.obj', 'hair.mtl'),
                loadObjModel('backpack.obj', 'backpack.mtl')
            ]).catch(e => {
                // Keep the error reporting, but remove the throw to allow the app to run without models
                console.error("Failed to load one or more OBJ assets:", e);
                loaderDiv.innerHTML = "Error loading models. Default player visible.";
                isPlayerLoaded = true; // Still allow game to start with blocky player
                return [null, null, null];
            });

            if (faceObj && hairObj && backpackObj) {
                // Set blocky mesh parts to invisible since we loaded custom ones
                headMesh.visible = false;
                
                // Center the backpack on the back of the torso
                backpackObj.position.set(0, 1.0, -0.25); // Torso center is Y=1.0, 0.25 back from center Z=0
                backpackObj.scale.set(0.01, 0.01, 0.01); // Scale down dramatically (Roblox exports are huge)
                torsoMesh.add(backpackObj); // Attach to the torso so it moves with the body

                // Center Face/Hair on the head anchor point
                // Note: OBJ assets from Roblox are often 100x too large, require scaling down and specific positioning/rotation
                const headScale = 0.01; 
                faceObj.scale.set(headScale, headScale, headScale);
                hairObj.scale.set(headScale, headScale, headScale);
                
                // Position adjustment: Roblox OBJ models typically place the origin far from the head.
                // These values (0, 0, 0) are placeholders. You may need to tweak them significantly 
                // after testing the initial load, likely adding Y offset and rotating 180 degrees.
                faceObj.position.set(0, -1.8, 0); 
                hairObj.position.set(0, -1.8, 0); 
                
                headAnchor.add(faceObj);
                headAnchor.add(hairObj);
                
                // --- Final Setup ---
                group.position.copy(spawnPoint);
                group.traverse(obj => { if (obj.isMesh) obj.castShadow = true; });

                scene.add(group);
                playerMesh = group;
                
                // Store references to the rotating parts for the animation loop
                playerMesh.userData = { 
                    legL, legR, armL, armR, 
                    faceObj, hairObj, backpackObj 
                };
            } else {
                 // Ensure playerMesh exists even if custom loading failed
                 // In this case, it already contains the blocky parts, so nothing needed here.
            }
            
            group.position.copy(spawnPoint);
            group.traverse(obj => { if (obj.isMesh) obj.castShadow = true; });
            scene.add(group);
            playerMesh = group;
            
            // Store references to the rotating parts for the animation loop
            playerMesh.userData = { 
                legL, legR, armL, armR, 
                faceObj: faceObj, hairObj: hairObj, backpackObj: backpackObj 
            };
            isPlayerLoaded = true;
        }


        // --- Game Logic and Animation ---

        function updateAnimation(time) {
            // Only run animations if the player model (and its components) are loaded
            if (!isPlayerLoaded || !playerMesh || !playerMesh.userData) return;
            
            const limbs = playerMesh.userData;

            // Reset rotations (A clean starting state for all limbs)
            limbs.legL.rotation.set(0,0,0);
            limbs.legR.rotation.set(0,0,0);
            limbs.armL.rotation.set(0,0,0);
            limbs.armR.rotation.set(0,0,0);

            // Safety check for OBJ accessories
            const hasBackpack = !!limbs.backpackObj;

            if (isClimbing) {
                 limbs.armL.rotation.x = -Math.PI; 
                 limbs.armR.rotation.x = -Math.PI; 
                 
                 if (climbPhase === 1 && climbTimer > 0.1) {
                     limbs.armL.rotation.x = -Math.PI / 2;
                     limbs.armR.rotation.x = -Math.PI / 2;
                 }
                 limbs.legL.rotation.x = -0.2; 
                 limbs.legR.rotation.x = -0.3;
                 
                 // Backpack slight vertical movement while climbing
                 if (hasBackpack) {
                    limbs.backpackObj.position.y = 1.0 + Math.sin(time * 10) * 0.05;
                 }
            } else if (!isGrounded && airTime > 0.15) {
                // JUMP ANIMATION: Arms and legs spread wide when airborne
                
                // Legs
                limbs.legL.rotation.z = -0.4;  // OUTWARDS LEFT
                limbs.legR.rotation.z = 0.4; // OUTWARDS RIGHT


                // Arms 
                limbs.armL.rotation.z = -0.8; // OUTWARDS LEFT 
                limbs.armR.rotation.z = 0.8;  // OUTWARDS RIGHT
                
                // Reset backpack position
                if (hasBackpack) {
                    limbs.backpackObj.position.y = 1.0; 
                }
                
            } else if (moveForward || moveBackward || moveLeft || moveRight) {
                // WALKING / RUNNING ANIMATION: Arm/Leg X-axis swing
                const speed = isShiftPressed ? 5 : 10;
                const angle = Math.sin(time * speed) * 0.8;
                limbs.legL.rotation.x = -angle;
                limbs.legR.rotation.x = angle;
                limbs.armL.rotation.x = angle;
                limbs.armR.rotation.x = -angle;
                
                // Reset backpack position
                if (hasBackpack) {
                    limbs.backpackObj.position.y = 1.0; 
                }
            } else {
                // STANDING / IDLE: Arms straight down, no animation.
                
                // Reset backpack position
                if (hasBackpack) {
                    limbs.backpackObj.position.y = 1.0; 
                }
            }

            // Continuously rotate hair slightly for a subtle effect
            if (limbs.hairObj) {
                 limbs.hairObj.rotation.y = Math.sin(time * 0.5) * 0.1;
            }
        }


        // --- Input Handling ---
        function onKeyDown(event) {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = true; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                case 'ArrowRight': case 'KeyD': moveRight = true; break;
                case 'ShiftLeft': case 'ShiftRight': isShiftPressed = true; break;
                case 'Space': 
                    isSpacePressed = true;
                    break;
                case 'KeyR': respawn('fall'); break; 
            }
        }


        function onKeyUp(event) {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = false; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                case 'ArrowRight': case 'KeyD': moveRight = false; break;
                case 'ShiftLeft': case 'ShiftRight': isShiftPressed = false; break;
                case 'Space': isSpacePressed = false; break;
            }
        }


        function onScroll(event) {
            cameraZoom += event.deltaY * 0.01;
            cameraZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, cameraZoom));
        }


        function pointerLockChange() {
            if (document.pointerLockElement === document.body) {
                isLocked = true;
                blocker.style.display = 'none';
                crosshair.style.display = 'block';
            } else {
                isLocked = false;
                blocker.style.display = 'flex';
                crosshair.style.display = 'none';
                moveForward = false; moveBackward = false; moveLeft = false; moveRight = false; isSpacePressed = false;
            }
        }


        function onMouseMove(event) {
            if (!isLocked) return;
            const movementX = event.movementX || 0;
            const movementY = event.movementY || 0;
            euler.y -= movementX * 0.002;
            euler.x -= movementY * 0.002;
            const limit = Math.PI / 2 - 0.1;
            euler.x = Math.max(-limit, Math.min(limit, euler.x));
        }


        // --- Physics Loop ---
        function respawn(type) {
            playerMesh.position.copy(spawnPoint);
            playerVelocity.set(0, 0, 0);
            momentum.set(0, 0, 0);
            if (playerMesh.position.y < -30) playerVelocity.set(0,0,0);
            
            // SFX
            if (type === 'fire') {
                if(sfxFire) { sfxFire.currentTime = 0; sfxFire.play().catch(e => {}); }
            } else {
                if(sfxDeath) { sfxDeath.currentTime = 0; sfxDeath.play().catch(e => {}); }
            }
        }


        function startClimb(p, halfW, halfD, radius, topY) {
            isClimbing = true;
            climbPhase = 0; // Start in Hang phase
            climbTimer = 0;
            playerVelocity.set(0, 0, 0);
            momentum.set(0, 0, 0);


            const pPos = p.mesh.position;
            const px = playerMesh.position.x;
            const pz = playerMesh.position.z;
            
            // Distances to faces
            const dx1 = (px - (pPos.x - halfW)); // Left face
            const dx2 = (px - (pPos.x + halfW)); // Right face
            const dz1 = (pz - (pPos.z - halfD)); // Back face
            const dz2 = (pz - (pPos.z + halfD)); // Front face
            
            const adx1 = Math.abs(dx1);
            const adx2 = Math.abs(dx2);
            const adz1 = Math.abs(dz1);
            const adz2 = Math.abs(dz2);
            
            const min = Math.min(adx1, adx2, adz1, adz2);
            
            // Hang Position: Shoulders at topY level.
            const hangY = topY - 1.2; 
            const endY = topY + 0.5;


            // Set Start Pos (Snapped to wall)
            climbStartPos.set(px, hangY, pz);
            climbTargetPos.set(px, endY, pz);


            const pushIn = 0.5; 
            
            if (min === adx1) {
                climbStartPos.x = pPos.x - halfW - radius;
                climbTargetPos.x = pPos.x - halfW + pushIn;
                climbNormal.set(-1, 0, 0); // Wall Normal is Left
            } else if (min === adx2) {
                climbStartPos.x = pPos.x + halfW + radius;
                climbTargetPos.x = pPos.x + halfW - pushIn;
                climbNormal.set(1, 0, 0);
            } else if (min === adz1) {
                climbStartPos.z = pPos.z - halfD - radius;
                climbTargetPos.z = pPos.z - halfD + pushIn;
                climbNormal.set(0, 0, -1);
            } else if (min === adz2) {
                climbStartPos.z = pPos.z + halfD + radius;
                climbTargetPos.z = pPos.z + halfD - pushIn;
                climbNormal.set(0, 0, 1);
            }
            
            playerMesh.position.copy(climbStartPos);
        }

        function triggerCheckpoint(p) {
            if(!p.triggered) {
                p.triggered = true;
                spawnPoint.set(p.mesh.position.x, p.mesh.position.y + 0.5 + 2, p.mesh.position.z);
                generateRandomStage();
                currentStage++;
                document.getElementById('stage-display').innerText = currentStage;
                const msg = document.getElementById('checkpoint-msg');
                msg.style.opacity = 1;
                setTimeout(() => { msg.style.opacity = 0; }, 2000);
                
                if(sfxCheck) { sfxCheck.currentTime=0; sfxCheck.play().catch(e => {}); }
            } else {
                spawnPoint.set(p.mesh.position.x, p.mesh.position.y + 0.5 + 2, p.mesh.position.z);
            }
        }

        // The animate loop starts only after init() resolves
        function animate() {
            requestAnimationFrame(animate);
            
            const dt = clock.getDelta();
            const timeScale = Math.min(dt * 60, 4);
            const time = Date.now() / 1000;

            if (!isLocked || !isPlayerLoaded) {
                renderer.render(scene, camera);
                return;
            }


            if (!isClimbing) {
                playerMesh.rotation.y = euler.y + Math.PI;
            } else if (isClimbing && climbPhase === 0) {
                playerMesh.rotation.y = Math.atan2(climbNormal.x, climbNormal.z) + Math.PI;
            }


            if (!isGrounded && !isClimbing) {
                airTime += dt;
            } else {
                airTime = 0;
            }


            if (!isGrounded && !isClimbing) {
                playerVelocity.y -= GRAVITY * timeScale;
            }


            if (isGrounded && isSpacePressed) {
                playerVelocity.y = JUMP_FORCE;
                isGrounded = false;
                if(sfxJump) { sfxJump.currentTime=0; sfxJump.play().catch(e => {}); }
            }


            let currentSpeed = 0;
            if (!isClimbing) {
                currentSpeed = isShiftPressed ? PLAYER_SPEED_WALK : PLAYER_SPEED_RUN;
            }
            
            const yaw = euler.y;
            const fwdX = -Math.sin(yaw);
            const fwdZ = -Math.cos(yaw);
            const rightX = Math.cos(yaw);
            const rightZ = -Math.sin(yaw);


            let moveX = 0;
            let moveZ = 0;


            if (!isClimbing) {
                if (moveForward) { moveX += fwdX; moveZ += fwdZ; }
                if (moveBackward) { moveX -= fwdX; moveZ -= fwdZ; }
                if (moveLeft) { moveX -= rightX; moveZ -= rightZ; }
                if (moveRight) { moveX += rightX; moveZ += rightZ; }
            }


            if (moveX !== 0 || moveZ !== 0) {
                const len = Math.sqrt(moveX*moveX + moveZ*moveZ);
                moveX = (moveX / len) * currentSpeed * timeScale;
                moveZ = (moveZ / len) * currentSpeed * timeScale;
                
                playerMesh.position.x += moveX;
                playerMesh.position.z += moveZ;
                
                if(isGrounded && sfxWalk) {
                    if(sfxWalk.paused) sfxWalk.play().catch(e => {});
                }
            } else {
                if(sfxWalk && !sfxWalk.paused) sfxWalk.pause();
            }
            
            if(!isGrounded && sfxWalk) sfxWalk.pause();


            playerMesh.position.add(momentum);
            momentum.multiplyScalar(0.94); 


            if (!isClimbing) playerMesh.position.y += playerVelocity.y * timeScale;


            checkPhysics(dt);
            updateAnimation(time);


            camera.quaternion.setFromEuler(euler);
            
            let zDist = cameraZoom;
            let yDist = Math.max(0, cameraZoom * 0.4); 
            let xOffset = 1.5;
            
            if (cameraZoom < 1.0) {
                xOffset = 0;
                yDist = 0; 
                zDist = -0.2; 
                playerMesh.visible = false; 
            } else {
                playerMesh.visible = true;
            }
            
            const camOffset = new THREE.Vector3(xOffset, 2 + yDist, zDist);
            camOffset.applyEuler(euler);
            camera.position.copy(playerMesh.position).add(camOffset);


            renderer.render(scene, camera);
        }


        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }


    </script>
</body>
</html>
