<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Infinite Random Obby</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; -webkit-user-select: none; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 8px;
            pointer-events: none;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
        }
        #checkpoint-msg {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #FFFF00;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }
        
        #blocker {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            color: white;
            z-index: 999;
        }
        #instructions {
            font-size: 24px;
            cursor: pointer;
            text-align: center;
            padding: 20px;
            background: rgba(0,0,0,0.7);
            border-radius: 10px;
            border: 2px solid white;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            border: 1px solid black;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 1000;
        }
    </style>
</head>
<body>

    <div id="info">Stage: <span id="stage-display">1</span></div>
    <div id="checkpoint-msg">CHECKPOINT! NEXT LEVEL GENERATED</div>
    <div id="crosshair"></div>

    <div id="blocker">
        <div id="instructions">
            <span style="font-size:30px">CLICK TO PLAY</span><br/><br/>
            WASD to Move<br/>
            SPACE to Jump<br/>
            SHIFT (Hold) to Hang on Ledges<br/>
            SPACE (While Hanging) to Wall Jump<br/>
            (Look L/R to aim Wall Jump)<br/>
            Scroll to Zoom<br/>
        </div>
    </div>

    <!-- SOUND EFFECTS -->
    <audio id="sfx-jump" src="jump.mp3"></audio>
    <audio id="sfx-check" src="checkpoint.wav"></audio>
    <audio id="sfx-death" src="death.mp3"></audio>
    <audio id="sfx-fire" src="firedeath.mp3"></audio>
    <audio id="sfx-walk" src="walk.mp3" loop></audio>

    <!-- Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- Game Constants ---
        const PLAYER_HEIGHT = 1.6; 
        const PLAYER_SPEED_RUN = 0.22; 
        const PLAYER_SPEED_WALK = 0.08;
        const JUMP_FORCE = 0.55;   
        const GRAVITY = 0.035;     
        const CLIMB_SPEED = 0.15;
        const PI_2 = Math.PI / 2;
        
        // --- Global Variables ---
        let camera, scene, renderer;
        let playerMesh;
        let platforms = [];
        let clock; 
        
        // Physics State
        let playerVelocity = new THREE.Vector3();
        let momentum = new THREE.Vector3(); 
        let isGrounded = false;
        
        // Climbing State
        let isClimbing = false;
        let climbPhase = 0; 
        let climbTimer = 0; 
        let climbStartPos = new THREE.Vector3(); 
        let climbTargetPos = new THREE.Vector3(); 
        let climbNormal = new THREE.Vector3(); 
        let airTime = 0; 
        
        // Game State
        let spawnPoint = new THREE.Vector3(0, 5, 0);
        let currentStage = 1;
        let nextStageStart = new THREE.Vector3(0, 0, 0); 
        let stageDirection = new THREE.Vector3(0, 0, -1); 
        
        // Input State
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let isShiftPressed = false;
        let isSpacePressed = false;
        
        // Camera State
        let euler = new THREE.Euler(0, 0, 0, 'YXZ');
        let cameraZoom = 6; 
        const MIN_ZOOM = 0.1; 
        const MAX_ZOOM = 15;
        
        // Pointer Lock
        let isLocked = false;
        const blocker = document.getElementById('blocker');
        const instructions = document.getElementById('instructions');
        const crosshair = document.getElementById('crosshair');

        // Sound Elements
        const sfxJump = document.getElementById('sfx-jump');
        const sfxCheck = document.getElementById('sfx-check');
        const sfxDeath = document.getElementById('sfx-death');
        const sfxFire = document.getElementById('sfx-fire');
        const sfxWalk = document.getElementById('sfx-walk');
        
        if(sfxWalk) sfxWalk.volume = 0.4; 

        init();
        animate();

        function init() {
            clock = new THREE.Clock();

            // 1. Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); 
            scene.fog = new THREE.Fog(0x87CEEB, 20, 150);

            // 2. Camera (FOV 85)
            camera = new THREE.PerspectiveCamera(85, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // 3. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // 4. Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            dirLight.shadow.camera.left = -50;
            dirLight.shadow.camera.right = 50;
            dirLight.shadow.camera.top = 50;
            dirLight.shadow.camera.bottom = -50;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // 5. Create Player
            createPlayer();

            // 6. Create Initial Level
            createPlatform(0, 0, 0, 10, 1, 10, 0xaaaaaa, 'spawn'); 
            nextStageStart.set(0, 0, -5); 
            generateRandomStage();

            // 7. Event Listeners
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('wheel', onScroll); 
            window.addEventListener('resize', onWindowResize);
            
            instructions.addEventListener('click', function() {
                document.body.requestPointerLock();
                // Interaction required to unlock audio
                if(sfxJump) sfxJump.play().then(() => {
                    sfxJump.pause();
                    sfxJump.currentTime = 0;
                }).catch(()=>{});
            });
            document.addEventListener('pointerlockchange', pointerLockChange);
            document.addEventListener('mousemove', onMouseMove);
        }

        // --- Level Generation ---
        function createPlatform(x, y, z, w, h, d, color, type = 'normal') {
            const geometry = new THREE.BoxGeometry(w, h, d);
            const material = new THREE.MeshLambertMaterial({ color: color });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            const platformData = {
                mesh: mesh,
                box: new THREE.Box3().setFromObject(mesh), 
                width: w,
                height: h,
                depth: d,
                type: type,
                stage: currentStage
            };
            platforms.push(platformData);
            return mesh;
        }

        function generateRandomStage() {
            const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff];
            const stageColor = colors[Math.floor(Math.random() * colors.length)];
            
            let curX = nextStageStart.x;
            let curY = nextStageStart.y;
            let curZ = nextStageStart.z;

            const obstaclesCount = 5 + Math.floor(Math.random() * 4); 

            for (let i = 0; i < obstaclesCount; i++) {
                const r = Math.random();
                const gap = 2.5 + Math.random() * 3.0;
                
                const driftX = (Math.random() - 0.5) * 8; 
                const driftY = (Math.random() - 0.4) * 2; 

                curZ -= gap;
                curX += driftX;
                curY += driftY;
                
                if(curX > 40) curX = 40;
                if(curX < -40) curX = -40;

                if (r < 0.3) {
                    // Standard Pad
                    const w = 3 + Math.random() * 3;
                    const d = 3 + Math.random() * 3;
                    curZ -= d/2;
                    createPlatform(curX, curY, curZ, w, 1, d, stageColor);
                    curZ -= d/2;
                } 
                else if (r < 0.5) {
                    // Lava Strips
                    const len = 8 + Math.random() * 6;
                    createPlatform(curX, curY, curZ - len/2, 4, 1, len, 0x333333);
                    
                    const lavaCount = Math.floor(len / 4); 
                    for(let k=0; k<lavaCount; k++) {
                        const lZ = curZ - (k * 4) - 2;
                        createPlatform(curX, curY + 0.6, lZ, 3.5, 0.2, 1.0, 0xff0000, 'lava');
                    }
                    curZ -= len;
                }
                else if (r < 0.7) {
                     // Thin Beam
                     const len = 6 + Math.random() * 6;
                     curZ -= len/2;
                     createPlatform(curX, curY, curZ, 1.2, 1, len, stageColor);
                     curZ -= len/2;
                }
                else {
                    // Stepping Stones
                    const steps = 3 + Math.floor(Math.random()*3);
                    for(let s=0; s<steps; s++) {
                        curZ -= 2.5; 
                        curX += (Math.random() - 0.5) * 5; 
                        curY += (Math.random() - 0.3) * 1.5; 
                        
                        createPlatform(curX, curY, curZ, 2, 1, 2, stageColor);
                    }
                }
            }

            // End Checkpoint
            curZ -= 4;
            createPlatform(curX, curY, curZ - 3, 8, 1, 6, 0x00FF00, 'checkpoint');
            
            const geo = new THREE.CylinderGeometry(0.5, 0.5, 5);
            const mat = new THREE.MeshBasicMaterial({color: 0xffff00});
            const pole = new THREE.Mesh(geo, mat);
            pole.position.set(curX + 3, curY + 2.5, curZ - 3);
            scene.add(pole);

            nextStageStart.set(curX, curY, curZ - 6);
        }

        // --- Player Creation (Original Blocky) ---
        function createPlayer() {
            const group = new THREE.Group();
            
            // Materials (Classic Noob)
            const matHead = new THREE.MeshLambertMaterial({ color: 0xFFFF00 }); // Yellow
            const matTorso = new THREE.MeshLambertMaterial({ color: 0x0000FF }); // Blue
            const matPants = new THREE.MeshLambertMaterial({ color: 0x00FF00 }); // Green
            const matSkin = matHead; // Re-use

            // 1. Torso (Simple Box)
            const torso = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 0.5), matTorso);
            torso.position.y = 1;
            group.add(torso);

            // 2. Head (Simple Box)
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), matHead);
            head.position.y = 1.8;
            group.add(head);

            // 3. Left Leg
            const legGeo = new THREE.BoxGeometry(0.4, 1.0, 0.4);
            legGeo.translate(0, -0.5, 0); // Pivot at Hip
            const legL = new THREE.Mesh(legGeo, matPants);
            legL.position.set(-0.25, 0.5, 0); 
            group.add(legL);

            // 4. Right Leg
            const legR = new THREE.Mesh(legGeo, matPants);
            legR.position.set(0.25, 0.5, 0); 
            group.add(legR);

            // 5. Left Arm
            const armGeo = new THREE.BoxGeometry(0.4, 1.0, 0.4);
            armGeo.translate(0, -0.5, 0); // Pivot at Shoulder
            const armL = new THREE.Mesh(armGeo, matSkin);
            armL.position.set(-0.75, 1.5, 0); 
            // Tuck in
            armL.rotation.z = 0.1;
            group.add(armL);

            // 6. Right Arm
            const armR = new THREE.Mesh(armGeo, matSkin);
            armR.position.set(0.75, 1.5, 0); 
            // Tuck in
            armR.rotation.z = -0.1;
            group.add(armR);

            group.position.copy(spawnPoint);
            group.traverse(obj => { if (obj.isMesh) obj.castShadow = true; });

            scene.add(group);
            playerMesh = group;
            
            playerMesh.userData = { legL, legR, armL, armR };
        }

        function updateAnimation(time) {
            if (!playerMesh || !playerMesh.userData) return;
            const limbs = playerMesh.userData;

            // Reset
            limbs.legL.rotation.set(0,0,0);
            limbs.legR.rotation.set(0,0,0);
            limbs.armL.rotation.set(0,0,0);
            limbs.armR.rotation.set(0,0,0);

            // Default Tucked Arms
            limbs.armL.rotation.z = 0.1;
            limbs.armR.rotation.z = -0.1;

            if (isClimbing) {
                 // Climb Pose
                 limbs.armL.rotation.x = -Math.PI; 
                 limbs.armR.rotation.x = -Math.PI; 
                 
                 if (climbPhase === 1 && climbTimer > 0.1) {
                     limbs.armL.rotation.x = -Math.PI / 2;
                     limbs.armR.rotation.x = -Math.PI / 2;
                 }
                 limbs.legL.rotation.x = -0.2; 
                 limbs.legR.rotation.x = -0.3;
            } else if (!isGrounded && airTime > 0.15) {
                // JUMP ANIMATION (Corrected: Side Split)
                // Use Z axis for Side-to-Side
                limbs.legL.rotation.z = 0.4;  // Out Left
                limbs.legR.rotation.z = -0.4; // Out Right

                // Arms Up and Out (Corrected angle: ~45 degrees)
                limbs.armL.rotation.z = 0.8; // Out Left 
                limbs.armR.rotation.z = -0.8;  // Out Right 
            } else if (moveForward || moveBackward || moveLeft || moveRight) {
                // Walk Animation
                const speed = isShiftPressed ? 5 : 10;
                const angle = Math.sin(time * speed) * 0.8;
                limbs.legL.rotation.x = -angle;
                limbs.legR.rotation.x = angle;
                limbs.armL.rotation.x = angle;
                limbs.armR.rotation.x = -angle;
            }
        }

        // --- Input Handling ---
        function onKeyDown(event) {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = true; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                case 'ArrowRight': case 'KeyD': moveRight = true; break;
                case 'ShiftLeft': case 'ShiftRight': isShiftPressed = true; break;
                case 'Space': 
                    isSpacePressed = true;
                    break;
                case 'KeyR': respawn('fall'); break; // Manual reset counts as fall
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = false; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                case 'ArrowRight': case 'KeyD': moveRight = false; break;
                case 'ShiftLeft': case 'ShiftRight': isShiftPressed = false; break;
                case 'Space': isSpacePressed = false; break;
            }
        }

        function onScroll(event) {
            cameraZoom += event.deltaY * 0.01;
            cameraZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, cameraZoom));
        }

        function pointerLockChange() {
            if (document.pointerLockElement === document.body) {
                isLocked = true;
                blocker.style.display = 'none';
                crosshair.style.display = 'block';
            } else {
                isLocked = false;
                blocker.style.display = 'flex';
                crosshair.style.display = 'none';
                moveForward = false; moveBackward = false; moveLeft = false; moveRight = false; isSpacePressed = false;
            }
        }

        function onMouseMove(event) {
            if (!isLocked) return;
            const movementX = event.movementX || 0;
            const movementY = event.movementY || 0;
            euler.y -= movementX * 0.002;
            euler.x -= movementY * 0.002;
            const limit = Math.PI / 2 - 0.1;
            euler.x = Math.max(-limit, Math.min(limit, euler.x));
        }

        // --- Physics Loop ---
        function respawn(type) {
            playerMesh.position.copy(spawnPoint);
            playerVelocity.set(0, 0, 0);
            momentum.set(0, 0, 0);
            if (playerMesh.position.y < -100) playerVelocity.set(0,0,0);
            
            // SFX
            if (type === 'fire') {
                if(sfxFire) { sfxFire.currentTime = 0; sfxFire.play(); }
            } else {
                if(sfxDeath) { sfxDeath.currentTime = 0; sfxDeath.play(); }
            }
        }

        function startClimb(p, halfW, halfD, radius, topY) {
            isClimbing = true;
            climbPhase = 0; // Start in Hang phase
            climbTimer = 0;
            playerVelocity.set(0, 0, 0);
            momentum.set(0, 0, 0);

            const pPos = p.mesh.position;
            const px = playerMesh.position.x;
            const pz = playerMesh.position.z;
            
            // Distances to faces
            const dx1 = (px - (pPos.x - halfW)); // Left face
            const dx2 = (px - (pPos.x + halfW)); // Right face
            const dz1 = (pz - (pPos.z - halfD)); // Back face
            const dz2 = (pz - (pPos.z + halfD)); // Front face
            
            const adx1 = Math.abs(dx1);
            const adx2 = Math.abs(dx2);
            const adz1 = Math.abs(dz1);
            const adz2 = Math.abs(dz2);
            
            const min = Math.min(adx1, adx2, adz1, adz2);
            
            // Hang Position: Shoulders at topY level.
            const hangY = topY - 1.2; 
            const endY = topY + 0.5;

            // Set Start Pos (Snapped to wall)
            climbStartPos.set(px, hangY, pz);
            climbTargetPos.set(px, endY, pz);

            const pushIn = 0.5; 
            
            if (min === adx1) {
                climbStartPos.x = pPos.x - halfW - radius;
                climbTargetPos.x = pPos.x - halfW + pushIn;
                climbNormal.set(-1, 0, 0); // Wall Normal is Left
            } else if (min === adx2) {
                climbStartPos.x = pPos.x + halfW + radius;
                climbTargetPos.x = pPos.x + halfW - pushIn;
                climbNormal.set(1, 0, 0);
            } else if (min === adz1) {
                climbStartPos.z = pPos.z - halfD - radius;
                climbTargetPos.z = pPos.z - halfD + pushIn;
                climbNormal.set(0, 0, -1);
            } else if (min === adz2) {
                climbStartPos.z = pPos.z + halfD + radius;
                climbTargetPos.z = pPos.z + halfD - pushIn;
                climbNormal.set(0, 0, 1);
            }
            
            playerMesh.position.copy(climbStartPos);
        }

        function checkPhysics(dt) {
            // Climbing Physics
            if (isClimbing) {
                if (climbPhase === 0) {
                    // --- PHASE 0: HANGING ---
                    playerMesh.position.copy(climbStartPos); // Stick to wall
                    
                    // 1. Wall Jump Logic
                    if (isSpacePressed) {
                        isClimbing = false;
                        isGrounded = false;
                        airTime = 0.2; // Small cooldown
                        playerVelocity.y = JUMP_FORCE * 1.1; 
                        
                        // Directional Jump Calculation
                        const normalAngle = Math.atan2(climbNormal.x, climbNormal.z);
                        // Camera direction (projected XZ)
                        const camAngle = Math.atan2(-Math.sin(euler.y), -Math.cos(euler.y));
                        
                        let diff = camAngle - normalAngle;
                        // Normalize diff to -PI to PI
                        while (diff > Math.PI) diff -= Math.PI * 2;
                        while (diff < -Math.PI) diff += Math.PI * 2;
                        
                        // Clamp to +/- 30 degrees (approx 0.52 rad)
                        const limit = Math.PI / 6;
                        diff = Math.max(-limit, Math.min(limit, diff));
                        
                        const finalAngle = normalAngle + diff;
                        
                        // Apply momentum based on final angle
                        momentum.set(Math.sin(finalAngle), 0, Math.cos(finalAngle)).multiplyScalar(0.5); 
                        
                        // SFX
                        if(sfxJump) { sfxJump.currentTime=0; sfxJump.play(); }

                        return;
                    }
                    
                    // 2. Climb Up Logic (If not holding Shift)
                    if (!isShiftPressed) {
                        climbPhase = 1; // Start Hoist
                        climbTimer = 0;
                    }
                } 
                else {
                    // --- PHASE 1: HOISTING ---
                    climbTimer += dt;
                    if (climbTimer < 0.4) { 
                        const t = climbTimer / 0.4;
                        playerMesh.position.lerpVectors(climbStartPos, climbTargetPos, t);
                    } else {
                        playerMesh.position.copy(climbTargetPos);
                        isClimbing = false;
                        isGrounded = true;
                    }
                }
                return;
            }

            // Standard Physics
            const playerRadius = 0.4;
            let onGround = false;
            let hitLedge = false;
            let ledgePlatform = null; 

            const nextX = playerMesh.position.x; 
            const nextZ = playerMesh.position.z;
            const feetY = playerMesh.position.y - 0.5;
            const headY = playerMesh.position.y + 1.0;

            for (let p of platforms) {
                if (Math.abs(p.mesh.position.z - nextZ) > 10 && Math.abs(p.mesh.position.x - nextX) > 10) continue;

                const pPos = p.mesh.position;
                const halfW = p.width / 2;
                const halfD = p.depth / 2;
                const halfH = p.height / 2;

                const minX = pPos.x - halfW - playerRadius;
                const maxX = pPos.x + halfW + playerRadius;
                const minZ = pPos.z - halfD - playerRadius;
                const maxZ = pPos.z + halfD + playerRadius;
                const minY = pPos.y - halfH;
                const maxY = pPos.y + halfH;

                if (nextX > minX && nextX < maxX && nextZ > minZ && nextZ < maxZ) {
                    if (feetY < maxY && headY > minY) {
                        const depthIntoTop = (maxY) - feetY;
                        
                        // Land on top
                        if (depthIntoTop > 0 && depthIntoTop < 0.6 && playerVelocity.y <= 0.1) {
                            onGround = true;
                            playerMesh.position.y = maxY + 0.5;
                            playerVelocity.y = 0;
                            momentum.set(0,0,0); // Stop momentum on land
                            
                            if(p.type === 'lava') { respawn('fire'); return; }
                            if(p.type === 'checkpoint') triggerCheckpoint(p);
                        } 
                        else if (feetY < maxY - 0.1) {
                            // Wall / Ledge Hit
                            // FIX: Must drop at least 0.5 units down (chest height) to grab
                            // AND must be falling (velocity < 0) to avoid grabbing on the way up
                            if (feetY > maxY - 1.5 && feetY < maxY - 0.5 && p.type !== 'lava' && playerVelocity.y < 0) {
                                hitLedge = true;
                                ledgePlatform = p;
                            } else {
                                // Push out
                                const dx1 = nextX - minX;
                                const dx2 = maxX - nextX;
                                const dz1 = nextZ - minZ;
                                const dz2 = maxZ - nextZ;
                                const minOverlap = Math.min(dx1, dx2, dz1, dz2);
                                
                                if (minOverlap === dx1) { playerMesh.position.x = minX; momentum.x = 0; }
                                else if (minOverlap === dx2) { playerMesh.position.x = maxX; momentum.x = 0; }
                                else if (minOverlap === dz1) { playerMesh.position.z = minZ; momentum.z = 0; }
                                else if (minOverlap === dz2) { playerMesh.position.z = maxZ; momentum.z = 0; }
                            }
                        }
                    }
                }
                // Safety Grab (Shift Walk off Edge)
                else if (isShiftPressed && p.type !== 'lava') {
                    const grabDist = 0.5;
                    if (nextX > minX - grabDist && nextX < maxX + grabDist && 
                        nextZ > minZ - grabDist && nextZ < maxZ + grabDist) {
                        // FIX: Must have actually fallen slightly below the surface to trigger
                        if (feetY > maxY - 1.2 && feetY < maxY - 0.2) {
                            hitLedge = true;
                            ledgePlatform = p;
                        }
                    }
                }
            }

            isGrounded = onGround;

            // Trigger Climb
            if (!isGrounded && hitLedge && ledgePlatform && airTime > 0.1) {
                // Calculate top Y
                const topY = ledgePlatform.mesh.position.y + ledgePlatform.height/2;
                startClimb(ledgePlatform, ledgePlatform.width/2, ledgePlatform.depth/2, playerRadius, topY);
            }

            if (playerMesh.position.y < -30) respawn('fall');
        }

        function triggerCheckpoint(p) {
            if(!p.triggered) {
                p.triggered = true;
                spawnPoint.set(p.mesh.position.x, p.mesh.position.y + 0.5 + 2, p.mesh.position.z);
                generateRandomStage();
                currentStage++;
                document.getElementById('stage-display').innerText = currentStage;
                const msg = document.getElementById('checkpoint-msg');
                msg.style.opacity = 1;
                setTimeout(() => { msg.style.opacity = 0; }, 2000);
                
                // SFX
                if(sfxCheck) { sfxCheck.currentTime=0; sfxCheck.play(); }
            } else {
                spawnPoint.set(p.mesh.position.x, p.mesh.position.y + 0.5 + 2, p.mesh.position.z);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            const timeScale = Math.min(dt * 60, 4);
            const time = Date.now() / 1000;

            if (!isLocked) {
                renderer.render(scene, camera);
                return;
            }

            // 1. Shift Lock Rotation (Normally)
            // While hanging (Phase 0), stay still OR align to wall. 
            // Currently animate sets rotation every frame.
            if (!isClimbing) {
                playerMesh.rotation.y = euler.y + Math.PI;
            } else if (isClimbing && climbPhase === 0) {
                // Keep player facing wall (-climbNormal)
                // climbNormal is (sin, 0, cos) of some angle.
                // Atan2(x, z) gives angle.
                // +PI to face opposite
                playerMesh.rotation.y = Math.atan2(climbNormal.x, climbNormal.z) + Math.PI;
            }

            // Update Air Timer
            if (!isGrounded && !isClimbing) {
                airTime += dt;
            } else {
                airTime = 0;
            }

            // 2. Physics: Gravity
            if (!isGrounded && !isClimbing) {
                playerVelocity.y -= GRAVITY * timeScale;
            }

            // NEW JUMP LOGIC: Continuous check
            if (isGrounded && isSpacePressed) {
                playerVelocity.y = JUMP_FORCE;
                isGrounded = false;
                // SFX
                if(sfxJump) { sfxJump.currentTime=0; sfxJump.play(); }
            }

            // 3. Movement
            // Disable movement input while climbing
            let currentSpeed = 0;
            if (!isClimbing) {
                currentSpeed = isShiftPressed ? PLAYER_SPEED_WALK : PLAYER_SPEED_RUN;
            }
            
            const yaw = euler.y;
            const fwdX = -Math.sin(yaw);
            const fwdZ = -Math.cos(yaw);
            const rightX = Math.cos(yaw);
            const rightZ = -Math.sin(yaw);

            let moveX = 0;
            let moveZ = 0;

            if (!isClimbing) {
                if (moveForward) { moveX += fwdX; moveZ += fwdZ; }
                if (moveBackward) { moveX -= fwdX; moveZ -= fwdZ; }
                if (moveLeft) { moveX -= rightX; moveZ -= rightZ; }
                if (moveRight) { moveX += rightX; moveZ += rightZ; }
            }

            if (moveX !== 0 || moveZ !== 0) {
                const len = Math.sqrt(moveX*moveX + moveZ*moveZ);
                moveX = (moveX / len) * currentSpeed * timeScale;
                moveZ = (moveZ / len) * currentSpeed * timeScale;
                
                playerMesh.position.x += moveX;
                playerMesh.position.z += moveZ;
                
                // Walking SFX Loop
                if(isGrounded && sfxWalk) {
                    if(sfxWalk.paused) sfxWalk.play();
                }
            } else {
                if(sfxWalk && !sfxWalk.paused) sfxWalk.pause();
            }
            
            if(!isGrounded && sfxWalk) sfxWalk.pause();

            // Apply Momentum
            playerMesh.position.add(momentum);
            momentum.multiplyScalar(0.94); // Decay momentum

            if (!isClimbing) playerMesh.position.y += playerVelocity.y * timeScale;

            // 4. Collision & Correction
            checkPhysics(dt);

            // 5. Animation
            updateAnimation(time);

            // 6. Camera
            camera.quaternion.setFromEuler(euler);
            
            let zDist = cameraZoom;
            let yDist = Math.max(0, cameraZoom * 0.4); 
            let xOffset = 1.5;
            
            if (cameraZoom < 1.0) {
                xOffset = 0;
                yDist = 0; 
                zDist = -0.2; 
                playerMesh.visible = false; 
            } else {
                playerMesh.visible = true;
            }
            
            const camOffset = new THREE.Vector3(xOffset, 2 + yDist, zDist);
            camOffset.applyEuler(euler);
            camera.position.copy(playerMesh.position).add(camOffset);

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

    </script>
</body>
</html>
